The Command pattern was chosen because it helps decouple the different inputs from the behavior. Each concrete
command class encapsulates an action (left, right, up, down, reset) so no matter which controller is used,
they can easily tell the model which action to perform without duplicating logic. It supports OCP because
we can easily add new commands (actions) without affecting existing code.

The Strategy pattern allows us to use different types of controllers, and decide at runtime (DIP). It also supports
OCP because we can easily add new controller types without affecting existing code

The Observer allows Model to update the View without having to loop through and directly update each observer. This could
Allow for multiple views or other pieces of code to be updated by the constantly changing model.

The iterator allows us to separate the collection from the View class to allow a method to maintain instance. This would
likely be more useful if this data structure was traversed through sequentially and not by index. We opted to not use something
similar in Model due to the number of features that would need to be overriden in order to maintain the functionality of the methods
in the class.